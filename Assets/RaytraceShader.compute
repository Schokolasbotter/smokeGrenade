// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSRaytrace

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _ResultTexture;
int _TextureWidth;
int _TextureHeight;

StructuredBuffer<int> _SmokeVoxels;
int _VoxelsX, _VoxelsY, VoxelsZ;


float3 _BoundsExtent;
float _VoxelResolution;

float4x4 _invProjectionMatrix;
float4x4 _CamToWorldMatrix;
float3 camPosWS;

float _RayMaxLength;

// Buffer to store ray vectors
RWStructuredBuffer<float3> _RayPositionsBuffer;
RWStructuredBuffer<float4> _RayColBuffer;


uint to1D(uint3 pos) {
    return pos.x + pos.y * _VoxelResolution + pos.z * _VoxelResolution * _VoxelResolution;
}

int getSmokeVoxel(float3 position, int indexx) {
   // int returnVal = -1;
    // Check if the world space position is currently within the bounds
    // If they are not, return 0;
    if (position.x < -_BoundsExtent.x || position.x > _BoundsExtent.x ||
        position.y < -_BoundsExtent.y + _BoundsExtent.y || position.y > _BoundsExtent.y+ _BoundsExtent.y ||
        position.z < -_BoundsExtent.z || position.z > _BoundsExtent.z)
    {
        _RayColBuffer[indexx] = float4(0., 0., 1.0,0.03);
        return -1;
    }



    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //@Laurent if your looking at this before i get back, below is the section that doesnt quite work, converting between the ws position of the raytrace and the index of the voxel grid
    // if we can get that working then thats the essential stuff done
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    //bound check works as intended

    // Get the index of the voxel in the _SmokeVoxels buffer that the current position falls within
 //   int3 positionVS = int3(
 ////       int(floor(position.x / _VoxelResolution)),
 //       int(floor(position.y / _VoxelResolution)),
//        int(floor(position.z / _VoxelResolution))
 //       );

 //   int index = positionVS.x + positionVS.y * int(_VoxelResolution) + positionVS.z * int(_VoxelResolution * _VoxelResolution);

   
     // Step 1: Add bounds extent and half voxel size to bring the position into voxel space

   // Vector3 boundsSize = _BoundsExtent * 2;

    float3 adjustedPosition = position + float3(_BoundsExtent.x, 0, _BoundsExtent.z);

    // Step 2: Calculate x, y, and z indices
    float x = adjustedPosition.x;
    float y = adjustedPosition.y;
    float z = adjustedPosition.z;

    // Step 3: Calculate the instance ID (index)
    uint instanceID = int(x + y * _VoxelsX + z * _VoxelsX * _VoxelsY);

    return _SmokeVoxels[instanceID];

   // return v;
}


[numthreads(8, 8, 1)]
void CSRaytrace(uint3 id : SV_DispatchThreadID)
{
    float3 origin = camPosWS;

    float2 uv = (id.xy / float2(_TextureWidth, _TextureHeight)); //gets the UV Coordinates
    float4 ndcCS = float4(uv.x * 2-1, uv.y * 2-1, 0, 1); //converts the uv coordinates to normalized device coordinates ndc in clip space
    float3 viewDir = mul(_invProjectionMatrix, ndcCS).xyz;
    float3 rayVector = mul(_CamToWorldMatrix, float4(viewDir, 0)).xyz;
    rayVector = normalize(rayVector);

    float4 col = float4(0.0, 1.0, 0.0, 0.5);  // Initialize color

    float3 positionWS = origin;

    uint rayIndex = id.y * _TextureWidth + id.x;

    float length = 0;
    float stepSize =3;
    float smokeValue = -1;

    // Ray marching loop
    while (smokeValue <= 0 && length < _RayMaxLength) {
        length += stepSize;
        positionWS = origin + length * rayVector;
        uint bufferIndex = rayIndex * uint(_RayMaxLength / stepSize) + uint(length / stepSize);
        
     //   if (bufferIndex < _RayPositionsBuffer.count) {
            _RayPositionsBuffer[bufferIndex] = positionWS;
            _RayColBuffer[bufferIndex] = float4(0.,0.,1.,1.);
    //    }

        smokeValue = getSmokeVoxel(positionWS,bufferIndex);
    }
    // If smokeValue is 1, set color to white
    if (smokeValue == 1) {
        col = float4(1.0, 1.0, 1.0, 1.0); // White color
    }
    if (smokeValue == -1) {
        col = float4(1.0, 0.0, 0.0, 0.5);
    }

    // Output the color to the render texture
    _ResultTexture[id.xy] = col;
}
